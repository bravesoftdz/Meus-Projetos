{ RRRRRR                  ReportBuilder Class Library                  BBBBB
  RR   RR                                                              BB   BB
  RRRRRR                 Digital Metaphors Corporation                 BB BB
  RR  RR                                                               BB   BB
  RR   RR                   Copyright (c) 1996-2009                    BBBBB   }

unit ppViewr;
                                                                                                              
interface

{$I ppIfDef.pas}

uses
  Windows,
  SysUtils,
  Messages,
  Classes,
  Graphics,
  Controls,
  Forms,
  Dialogs,
  Menus,
  StdCtrls,
  ExtCtrls,
  Mask,
  Buttons,

{$IFDEF NewGraphics}
 ppGraphicsContext,
{$ENDIF}
  ppComm,
  ppTypes,
  ppUtils,
  ppRTTI,
  ppDevice,
  ppProd,
  ppDrwCmd,
  ppPrnDev,
  ppPrintr,
  ppScrollbox,
  ppGraphicsDevice;

type

  TppViewer = class;
  TppViewerPaintBox = class;

  {@TppScreenDevice

    The ScreenDevice is usually used in conjunction with a TppViewer
    component.  The ScreenDevice receives the pages generated by the report
    engine and renders them onto a bitmap based on the viewable area of the
    Viewer and the ZoomSetting of the Viewer.  Once the page is rendered,          
    it is copied onto a standard PaintBox control in the Viewer.  The
    Screen Device caches the current page displayed in the Viewer, re-
    rendering it when the ZoomSetting or ZoomPercentage properties are
    modified.  The ScreenDevice requests the first page of the report when
    the Publisher calls the StartJob method.  The EndJob and CancelJob
    methods are not used by the ScreenDevice.}

 
  TppScreenDevice = class(TppGraphicsDevice)
    private
      FShowStatus: Boolean;
      FViewer: TppViewer;

      function CalculateZoomPercentage: Integer;
      procedure ResetPageImage;

    protected
      procedure AfterReceivePage(aPage: TppPage); override;
      procedure AfterRenderpage; override;
      procedure BeforeRenderPage; override;
      procedure CalculateScaledPageSize; override;
      procedure SetStatus(const aMessage: String); override;

    public
      constructor Create(aOwner: TComponent); override;
      procedure Cancel;

      class function DeviceName: String; override;
      function DrawUpdateable(aDrawCommand: TppDrawCommand): Boolean; override;

      procedure EventNotify(aCommunicator: TppCommunicator; aEventID: Integer; aParams: TraParamList); override;
      function FinalPagesOnly: Boolean; override;
      procedure Notify(aCommunicator: TppCommunicator; aOperation: TppOperationType); override;
      procedure RenderFullBlankPage;
      procedure Reset; override;

      property ShowStatus: Boolean read FShowStatus write FShowStatus default True;
      property Viewer: TppViewer read FViewer;

  end; {class, TppScreenDevice}


  {@TppViewer

    This component inherits directly from
    <EXTLINK borland://TCustomPanel_object>TCustomPanel</EXTLINK>
    and provides a surface for displaying a preview of your report. You can use
    a viewer to create a custom print preview form. To do this, drop a TppViewer
    component on a form and assign the Report property to a TppReport component.
    Call the PrintToDevices method at run-time, and the report will be displayed
    in your viewer.

    You can register your own Print Preview form. To see an example of how to do
    so, review the source of the TppPrintPreview class in the ppPrvDlg unit.}


  {@TppViewer.Color

    Defaults to clBtnShadow. Specifies the background color that is displayed as
    a border around the viewer. }

  {@TppViewer.OnHyperLinkClick

    This event fires when a report hyperlink is clicked. Use this event to perform
    custom processing for hyperlinks. To prevent the default behavior of opening
    a web page, set aHandled to True. }

  {@TppViewer.OnPageChange

    This event fires each time the TppViewer Page property changes.}

  {@TppViewer.OnPrintStateChange

    This event fires whenever the StartJob, EndJob or CancelJob methods of the
    ScreenDevice embedded in the viewer are called.}

  {@TppViewer.OnStatusChange

    This event fires each time the Status property changes.}

  {@TppViewer.PageColor

    Defaults to clWhite. Specifies the color of the page image rendered by the
    viewer.}

  {@TppViewer.Report

    The report property indicates the TppReport component to which the viewer
    has been assigned.  If the viewer is not assigned to any report, this
    property is nil.}

  {@TppViewer.Status

    Run-time and read-only.  The status property contains a string summarizing
    the current status of the report, such as 'Preview Page 1 of 15.'  The
    built-in Print Preview Form uses the status property to display feedback to
    the user on the status bar.}

  {@TppViewer.ZoomPercentage

    Value between 25 and 250 which indicates the scaling percentage to be used
    when drawing the report page on the viewer panel. This value is only
    applicable when the ZoomSetting is set to zsPercentage.}

  {@TppViewer.ZoomSetting

    Indicates how pages will be displayed in the viewer.

    <Table>
    Value               Meaning
    --------------      -------
    zsWholePage         Entire page is scaled to fit into the viewing area
    zsPageWidth         PageWidth is fitted to width of viewing area, vertical
                        scrollbar is provided to view page height
    zs100Percent        Page is shown at full size, both vertical and horizontal
                        scrollbars are provided as necessary
    zsPercentage        Page is show based on the value of the ZoomPercentage
                        property.
    </Table>}

  TppViewer = class(TCustomPanel)
  private
    FCurrentZoomSetting: TppZoomSettingType;
    FDesignViewer: Boolean;
    FIncrementalPainting: Boolean;
    FNeedToUpdateScrollBars: Boolean;
    FOnReset: TNotifyEvent;
    FPaintBox: TppViewerPaintBox;
    FPageColor: TColor;
    FProducer: TppProducer;
    FSaveCursor: TCursor;
    FScreenDevice: TppScreenDevice;
    FScrollBox: TppScrollBox;
    FSettingCursor: Boolean;
    FZoomPercentage: Integer;
    FZoomSetting: TppZoomSettingType;
    FEnabled: Boolean;
    FResizeCount: Integer;
    FSaveDevice: String;
    FSavePrinterSetup: TppPrinterSetup;
    FSaveShowAutoSearchDialog: Boolean;
    FWalkieTalkie: TppCommunicator;

    {events}
    FOnStatusChange: TNotifyEvent;
    FOnPageChange: TNotifyEvent;
    FOnPrintStateChange: TNotifyEvent;
    FInitialized: Boolean;
    FOnHyperlinkClick: TppHyperLinkClickEvent;

    function  GetAbsolutePageNo: Longint;
    function  GetBusy: Boolean;
    function  GetCalculatedZoom: Integer;
    function  GetStatus: String;
    procedure PaintBoxMouseDownEvent(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure PaintBoxMouseMoveEvent(Sender: TObject; Shift: TShiftState; X,Y: Integer);
    procedure PaintBoxClickEvent(Sender: TObject);
    procedure PaintBoxPaintEvent(Sender: TObject);
    procedure ResetCursor;
    procedure UpdatePageSize;

    procedure StartJobEvent(Sender: TObject);
    procedure CancelJobEvent(Sender: TObject);
    procedure EndJobEvent(Sender: TObject);
    function GetCurrentPage: TppPage;
    procedure WalkieTalkieEventNotifyEvent(Sender: TObject;aCommunicator: TppCommunicator; aEventID: Integer; aParams: TraParamList);
    function GetResizing: Boolean;
    procedure OpenWebAddress(aWebAddress: String);
    procedure SetResizing(aResizing: Boolean);

  protected
    function CreateScreenDevice: TppScreenDevice; virtual;

    {property handling routines}
    function  OkayToPaint: Boolean;
    procedure SetProducer(aProducer: TppProducer);
    procedure SetZoomPercentage(Value: Integer);
    procedure SetZoomSetting(Value: TppZoomSettingType);
    procedure SetPageColor(aColor: TColor);
    procedure Resize; override;
    procedure WndProc(var Message: TMessage); override;
    procedure UpdateScrollBars;
    property Resizing: Boolean read GetResizing write SetResizing;

  public
    constructor Create(aOwner: TComponent); override;
    destructor Destroy; override;

    procedure Loaded; override;

    function IsResizing: Boolean;

    procedure Initialize;
    procedure Cancel;

    {triggers}
    procedure DoOnPageChange;
    procedure DoOnStatusChange;
    procedure DoOnReset;
    procedure DoOnPrintStateChange;

    procedure DisplayAutoSearchDialog;
    function  FindClickableDrawCommand(aX, aY: Integer; var aDrawCommand: TppDrawCommand): Boolean; overload;
    function  FindClickableDrawCommand(var aDrawCommand: TppDrawCommand): Boolean; overload;
    procedure FirstPage;
    function  GetDevice: TppDevice;
    procedure GotoPage(aAbsolutePageNo: Longint);
    procedure LastPage;
    procedure NextPage;
    procedure Print;
    procedure PriorPage;
    procedure RefreshPage;
    procedure RegenerateReport;
    procedure Reset;
    procedure Scroll(aDirection: TppDirectionType);

    property AbsolutePageNo: Longint read GetAbsolutePageNo;
    property Busy: Boolean read GetBusy;
    property CalculatedZoom: Integer read GetCalculatedZoom;
    property DesignViewer: Boolean read FDesignViewer write FDesignViewer;
    property IncrementalPainting: Boolean read FIncrementalPainting write FIncrementalPainting;
    property OnReset: TNotifyEvent read FOnReset  write FOnReset;
    property PaintBox: TppViewerPaintBox read FPaintBox;
    property ScrollBox: TppScrollbox read FScrollBox;
    property ScreenDevice: TppScreenDevice read FScreenDevice;
    property Status: String read GetStatus;
    property CurrentPage: TppPage read GetCurrentPage;
    property WalkieTalkie: TppCommunicator read FWalkieTalkie;

  published
    property Align;
    property Alignment;
    property Anchors;
    property BevelInner;
    property BevelOuter;
    property BevelWidth;
    property BorderWidth;
    property BorderStyle;
    property Color;
    property Ctl3D;
    property PageColor: TColor read FPageColor write SetPageColor;
    property ParentCtl3D;
    property ParentShowHint;
    property PopupMenu;
    property ShowHint;
    property Report: TppProducer read FProducer write SetProducer;
    property Visible;
    property ZoomPercentage: Integer read FZoomPercentage write SetZoomPercentage;
    property ZoomSetting: TppZoomSettingType read FZoomSetting write SetZoomSetting;

    property OnClick;
    property OnDblClick;
    property OnDragDrop;
    property OnDragOver;
    property OnMouseDown;
    property OnMouseMove;
    property OnMouseUp;
    property OnPageChange: TNotifyEvent read FOnPageChange  write FOnPageChange;
    property OnPrintStateChange: TNotifyEvent read FOnPrintStateChange write FOnPrintStateChange;
    property OnResize;
    property OnHyperlinkClick: TppHyperLinkClickEvent read FOnHyperlinkClick write FOnHyperlinkClick;
    property OnStatusChange: TNotifyEvent read FOnStatusChange  write FOnStatusChange;
  end; {class, TppViewer}


  TppViewerPaintBox = class(TPaintBox)
    private
      FScreenDevice: TppScreenDevice;

    protected

    public
      property ScreenDevice: TppScreenDevice read FScreenDevice write FScreenDevice;
      
  end;


implementation

uses
  ppPlainText,
  ppRotatedText,
  ppReport;

{******************************************************************************
 *
 ** V I E W E R
 *
{******************************************************************************}

{------------------------------------------------------------------------------}
{ TppViewer.Create }

constructor TppViewer.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);

  FInitialized := False;

  {set style for viewer controls}
  Font.Size  := 8;
  Font.Style := [];
  Font.Color := clBtnShadow;

  BevelOuter := bvNone;
  Color   := clBtnShadow;

  Height := 120;
  Width  := 320;

  FCurrentZoomSetting     := zsWholePage;
  FDesignViewer           := False;
  FEnabled                := False;
  FIncrementalPainting    := False;
  FNeedToUpdateScrollBars := True;
  FOnPageChange           := nil;
  FOnStatusChange         := nil;
  FScrollBox              := nil;
  FSettingCursor          := False;
  FPageColor              := clWhite;
  FPaintBox               := nil;
  FZoomSetting            := zsWholePage;
  FZoomPercentage         := 100;

  FScreenDevice             := CreateScreenDevice;
  FScreenDevice.OnStartJob  := StartJobEvent;
  FScreenDevice.OnEndJob    := EndJobEvent;
  FScreenDevice.OnCancelJob := CancelJobEvent;

  FWalkieTalkie := TppCommunicator.Create(nil);
  FWalkieTalkie.EventNotifies := [ciProducerAfterPrintToPrinter];
  FWalkieTalkie.OnEventNotify := WalkieTalkieEventNotifyEvent;

end; {constructor, TppViewer}

{------------------------------------------------------------------------------}
{ TppViewer.Destroy }

destructor TppViewer.Destroy;         
begin

  FWalkieTalkie.Free;

  {free screen device}
  FScreenDevice.Free;

  {free paintbox}
  FPaintBox.Free;

  {free parent scrollbox last}
  FScrollBox.Free;

  inherited Destroy;

end; {destructor, TppViewer}

{------------------------------------------------------------------------------}
{ TppViewer.CreateScreenDevice }

function TppViewer.CreateScreenDevice: TppScreenDevice;
begin
  Result := TppScreenDevice.Create(Self);
end;

{------------------------------------------------------------------------------}
{ TppViewer.SetProducer }

procedure TppViewer.SetProducer(aProducer: TppProducer);
begin
  FProducer := aProducer;

  if (FProducer <> nil) then
    begin
      FScreenDevice.Publisher := FProducer.Publisher;
      FProducer.AddEventNotify(FScreenDevice);
    end
  else
    begin
      FScreenDevice.Publisher := nil;
    end;

  UpdatePageSize;

end; {procedure, SetProducer}

{------------------------------------------------------------------------------}
{ TppViewer.Reset}

procedure TppViewer.Reset;
begin
  UpdatePageSize;
  FScreenDevice.Reset;

  DoOnReset;
end;

{------------------------------------------------------------------------------}
{ TppViewer.UpdatePageSize}

procedure TppViewer.UpdatePageSize;
begin

  if FProducer <> nil then
    begin
      FScreenDevice.Page.PageDef.mmHeight := FProducer.PrinterSetup.PageDef.mmHeight;
      FScreenDevice.Page.PageDef.mmWidth := FProducer.PrinterSetup.PageDef.mmWidth;
    end;
end; {procedure, UpdatePageSize}

{------------------------------------------------------------------------------}
{ TppViewer.Cancel }

procedure TppViewer.Cancel;
begin
  FScreenDevice.Cancel;
end; {procedure, Cancel}

{@TppViewer.DisplayAutoSearchDialog
 Calls the DisplayAutoSearchDialog method of the report.  This method is called
 when the search icon is clicked.}

procedure TppViewer.DisplayAutoSearchDialog;
begin
  if ScreenDevice.Busy then Exit;

  if (FProducer.DisplayAutoSearchDialog) then
    RegenerateReport;

end; {procedure, DisplayAutoSearchDialog}

{@TppViewer.RegenerateReport
 Call this method to regenerate the report pages. Resets the screen device
 and the publisher, and then makes a page request.}

procedure TppViewer.RegenerateReport;
begin

  if ScreenDevice.Busy then Exit;

  FEnabled := False;
  try
    FScreenDevice.Publisher.Reset;
    Reset;
  finally
    FEnabled := True;
  end;

    if Assigned(FOnReset) then FOnReset(Self);

    FScreenDevice.MakePageRequest;


end; {procedure, RegenerateReport}


{@TppViewer.Print
 Call the Print method to display the Print Dialog and print the currently
 previewed report to the printer.}

procedure TppViewer.Print;
begin

  if FScreenDevice.Busy then Exit;

  if (FProducer <> nil) then
    begin

      {detach screen device}
      FScreenDevice.Publisher := nil;

      {set current page}
      if FScreenDevice.AbsolutePageNo = 0 then
        FProducer.CurrentPage := 1
      else
        FProducer.CurrentPage := FScreenDevice.AbsolutePageNo;

      {print the report}
      FSaveDevice := FProducer.DeviceType;
      FSavePrinterSetup := TppPrinterSetup.Create(nil);
      FSavePrinterSetup.Assign(FProducer.PrinterSetup);

      FSaveShowAutoSearchDialog := FProducer.ShowAutoSearchDialog;

      FProducer.AddEventNotify(FWalkieTalkie);

      FProducer.ShowAutoSearchDialog := False;
      FProducer.DeviceType := TppPrinterDevice.DeviceName;

      if (FProducer is TppReport) then
        TppReport(FProducer).PrintWithSameParameters
      else
        FProducer.Print;

    end;

end; {procedure, Print}

{------------------------------------------------------------------------------}
{ TppViewer.WalkieTalkieEventNotifyEvent }

procedure TppViewer.WalkieTalkieEventNotifyEvent(Sender: TObject; aCommunicator: TppCommunicator; aEventID: Integer; aParams: TraParamList);
begin

  if (aEventID = ciProducerAfterPrintToPrinter) and (aCommunicator = FProducer) then
    begin
      FProducer.DeviceType := FSaveDevice;
      FProducer.ShowAutoSearchDialog := FSaveShowAutoSearchDialog;

      {re-attach screen device}
      FScreenDevice.Publisher := Report.Publisher;

      {the printer settings have been changed, thus we must regen to
      the viewer}
      if (FSavePrinterSetup <> nil) and not(FSavePrinterSetup.IsEqual(FProducer.PrinterSetup)) then
        FScreenDevice.MakePageRequest;

      FSavePrinterSetup.Free;
      FSavePrinterSetup := nil;
    end;

end;


{------------------------------------------------------------------------------}
{ TppViewer.GetAbsolutePageNo }

function TppViewer.GetAbsolutePageNo: Longint;
begin
  Result := FScreenDevice.AbsolutePageNo;
end;

{------------------------------------------------------------------------------}
{ TppViewer.GetDevice }

function  TppViewer.GetDevice: TppDevice;
begin
  Result := FScreenDevice;
end;

{------------------------------------------------------------------------------}
{ TppViewer.GetCalculatedZoom }

function  TppViewer.GetCalculatedZoom: Integer;
begin
  Result := FScreenDevice.CalculatedZoom;
end;

{------------------------------------------------------------------------------}
{ TppViewer.GetStatus }

function TppViewer.GetStatus: String;
begin
  Result := FScreenDevice.Status;
end;

{------------------------------------------------------------------------------}
{ TppViewer.GetBusy }

function TppViewer.GetBusy: Boolean;
begin
  Result := FScreenDevice.Busy;
end;

{------------------------------------------------------------------------------}
{ TppViewer.WndProc }

procedure TppViewer.WndProc(var Message: TMessage);
begin

 if Message.Msg = CM_CURSORCHANGED then
    begin
      if (FPaintBox <> nil) then
        FPaintBox.Cursor := Cursor;

      if not(FSettingCursor) then
        FSaveCursor := Cursor;
    end;

 inherited WndProc(Message);

end;

{------------------------------------------------------------------------------}
{ TppViewer.Initialize }

procedure TppViewer.Initialize;
begin

  if FInitialized then Exit;

  if (csReading in ComponentState) or (csLoading in ComponentState) then Exit;

  FInitialized := True;

  {create paint boxes}
  FScrollBox  := TppScrollBox.Create(Self);
  FPaintBox   := TppViewerPaintBox.Create(Self);
  FPaintBox.ScreenDevice := FScreenDevice;

  {set parent relationships}
  FScrollBox.Parent := Self;
  FScrollBox.BorderStyle := bsNone;
  FScrollBox.VertScrollbar.Tracking := True;
  FScrollBox.HorzScrollbar.Tracking := True;
//  FScrollBox.BevelOuter := bvNone;

  FPaintBox.Parent  := FScrollBox;
  FPaintBox.Visible := False;

  {remove page flicker}
  FScrollBox.DoubleBuffered := True;

  {configure zoom & page paintboxes}
  FScrollBox.Visible := False;
  FScrollBox.Align   := alClient;

  FPaintBox.Align  := alClient;
  FPaintBox.Color  := clBtnShadow;

  {assign paint routine to paint boxes}
  FPaintBox.Cursor      := Cursor;
  FPaintBox.OnClick     := PaintBoxClickEvent;
  FPaintBox.OnMouseDown := PaintBoxMouseDownEvent;
  FPaintBox.OnMouseMove := PaintBoxMouseMoveEvent;
  FPaintBox.OnPaint     := PaintBoxPaintEvent;
  FPaintBox.OnDblClick  := OnDblClick;
  FPaintBox.OnDragDrop  := OnDragDrop;
  FPaintBox.OnDragOver  := OnDragOver;
  FPaintBox.OnMouseUp   := OnMouseUp;

  FSaveCursor := Cursor;

  {hide paintbox at design-time}
  if (csDesigning in ComponentState) then
    FPaintBox.Visible := False;

  Invalidate;

end; {procedure, Initialize}

{------------------------------------------------------------------------------}
{ TppViewer.Loaded }

procedure TppViewer.Loaded;
begin

  inherited Loaded;

  Initialize;

end; {procedure, Loaded}


{------------------------------------------------------------------------------}
{ TppViewer.OkayToPaint }

function TppViewer.OkayToPaint: Boolean;
begin

  if not FEnabled then
    Result := False

  else if (csDesigning in ComponentState) or FIncrementalPainting then
    Result := False

  else
    Result := True;

  if not FInitialized then
    Initialize;

end; {procedure, OkayToPaint}

{------------------------------------------------------------------------------}
{ TppViewer.RefreshPage }

procedure TppViewer.RefreshPage;
begin
  PaintBoxPaintEvent(Self);
end; {procedure, RefreshViewer}

{------------------------------------------------------------------------------}
{ TppViewer.DoOnPageChange }

procedure TppViewer.DoOnPageChange;
begin
  if Assigned(FOnPageChange) then FOnPageChange(Self);

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerPageChange, nil);
end; {procedure, DoOnPageChange}

{------------------------------------------------------------------------------}
{ TppViewer.DoOnStatusChange }

procedure TppViewer.DoOnStatusChange;
begin
  if Assigned(FOnStatusChange) then FOnStatusChange(Self);

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerStatusChange, nil);
end; {procedure, DoOnStatusChange}
          
{------------------------------------------------------------------------------}
{ TppViewer.DoOnPrintStateChange }

procedure TppViewer.DoOnPrintStateChange;
begin
  RefreshPage;

  if Assigned(FOnPrintStateChange) then FOnPrintStateChange(Self);

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerPrintStateChange, nil);
end; {procedure, StartJobEvent}

{------------------------------------------------------------------------------}
{ TppViewer.DoOnReset}

procedure TppViewer.DoOnReset;
begin
  if Assigned(FOnReset) then FOnReset(Self);

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerReset, nil);
end; {procedure, Reset}

{------------------------------------------------------------------------------}
{ TppViewer.Resize }

procedure TppViewer.Resize;
begin

  inherited Resize;

  {if you remove this, the Design-Time Viewer will GPF}
  if (csDestroying in ComponentState) then Exit;

  {check reading only here, not loading}
  if (csReading in ComponentState) then Exit;

  if not(OkayToPaint) then Exit;

  Resizing := True;

  FScreenDevice.RenderPage;

  UpdateScrollBars;

  {indicate to preview form that page has changed}
  if  not (csLoading in ComponentState) then
    DoOnPageChange;

  PaintBoxPaintEvent(Self);

  Resizing := False;

end; {procedure, Resize}

{------------------------------------------------------------------------------}
{ TppViewer.PaintBoxPaintEvent }

procedure TppViewer.PaintBoxPaintEvent(Sender: TObject);
var
  lCanvas: TCanvas;

begin

  if not(OkayToPaint) then Exit;

  lCanvas := FPaintBox.Canvas;

  lCanvas.CopyRect(lCanvas.ClipRect, FScreenDevice.PageImage.Canvas, lCanvas.ClipRect);

end; {procedure, PaintBoxPaintEvent}

{------------------------------------------------------------------------------}
{ TppViewer.PaintBoxClickEvent }

procedure TppViewer.PaintBoxClickEvent(Sender: TObject);
var
  lPoint: TPoint;
  lDrawCommand: TppDrawCommand;
begin
  GetCursorPos(lPoint);

  lPoint := FPaintBox.ScreenToClient(lPoint);
  lDrawCommand := nil;
  
  if FindClickableDrawCommand(lPoint.X, lPoint.Y, lDrawCommand) then
    begin

      lDrawCommand.DoOnClick;

      if (lDrawCommand is TppDrawText) and (TppDrawText(lDrawCommand).HyperLink <> '') then
        OpenWebAddress(TppDrawText(lDrawCommand).HyperLink);

      if lDrawCommand.RedrawPage then
        begin
          lDrawCommand.RedrawPage := False;

          {tell publisher we just want a single page}
          FScreenDevice.PageRequest.PageSetting := psSinglePage;
          FScreenDevice.PageRequest.PageRequested := AbsolutePageNo;

          if lDrawCommand.ExpansionKey <> '' then
            FScreenDevice.PageRequest.ExpansionKey := lDrawCommand.ExpansionKey
          else
            FScreenDevice.PageRequest.DrawCommandClickIndex := lDrawCommand.Page.IndexOfDrawCommand(lDrawCommand);

          FScreenDevice.MakePageRequest;

          // reset
          FScreenDevice.PageRequest.ExpansionKey := '';
          FScreenDevice.PageRequest.DrawCommandClickIndex := -1;

          {reset cursor}
          ResetCursor;
        end;
    end;

  {trigger panels onclick event}
  Click;

end; {procedure, PaintBoxClickEvent}

{------------------------------------------------------------------------------}
{ TppViewer.ResetCursor }

procedure TppViewer.ResetCursor;
var
  lPoint: TPoint;
begin

  GetCursorPos(lPoint);

  SetCursorPos(lPoint.X - 1, lPoint.Y - 1);
  Application.ProcessMessages;

  SetCursorPos(lPoint.X, lPoint.Y);
  Application.ProcessMessages;

end; {procedure, ResetCursor}

{------------------------------------------------------------------------------}
{ TppViewer.PaintBoxMouseDownEvent }

procedure TppViewer.PaintBoxMouseDownEvent(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin

  FWalkieTalkie.SendEventNotify(FWalkieTalkie, ciViewerMouseDown, nil);

  {trigger panels mouse down event}
  MouseDown(Button, Shift, X, Y);
end;

{------------------------------------------------------------------------------}
{ TppViewer.PaintBoxMouseMoveEvent }

procedure TppViewer.PaintBoxMouseMoveEvent(Sender: TObject; Shift: TShiftState; X,Y: Integer);
var
  lPoint: TPoint;
  lDrawCommand: TppDrawCommand;
  lbFound: Boolean;
begin
  GetCursorPos(lPoint);

  lPoint := ScreenToClient(lPoint);

  FSettingCursor := True;

  lbFound := FindClickableDrawCommand(X, Y, lDrawCommand);

  {force cursor to change}
  Cursor := FSaveCursor;

  if lbFound then
    Cursor := crHandPoint;

  FSettingCursor := False;

  {trigger panels mouse move event}
  MouseMove(Shift, X, Y);

end; {procedure, PaintBoxMouseMoveEvent}

{------------------------------------------------------------------------------}
{ TppViewer.SetPageColor }

procedure TppViewer.SetPageColor(aColor: TColor);
begin

  FPageColor := aColor;
  FScreenDevice.PageColor := FPageColor;

  Invalidate;

end; {procedure, SetZoomPercentage}

{------------------------------------------------------------------------------}
{ TppViewer.SetZoomSetting }

procedure TppViewer.SetZoomSetting(Value: TppZoomSettingType);
begin

  FZoomSetting := Value;

  {check reading only here, not loading}
  if (csReading in ComponentState) then Exit;

  if not(OkayToPaint) then Exit;

  if not Visible then
    begin
      Invalidate;
      Exit;
    end;

  {paint uses this var to get back in sync}
  FCurrentZoomSetting := Value;

  {set zoom}
  FPaintBox.Visible := False;

  FScreenDevice.RenderPage;

  FNeedToUpdateScrollBars := True;

  UpdateScrollBars;

  PaintBoxPaintEvent(Self);

  FPaintBox.Visible := True;

end; {procedure, SetZoomSetting}

{------------------------------------------------------------------------------}
{ TppViewer.SetZoomPercentage }

procedure TppViewer.SetZoomPercentage(Value: Integer);
begin

  if (Value < 25) then
    FZoomPercentage := 25

  else if (Value > 250) then
    FZoomPercentage := 250
    
  else
    FZoomPercentage := Value;

  SetZoomSetting(zsPercentage);

end; {procedure, SetZoomPercentage}

{------------------------------------------------------------------------------}
{ TppViewer.UpdateScrollBars }

procedure TppViewer.UpdateScrollBars;
begin
  if (csReading in ComponentState) or (csLoading in ComponentState) then Exit;

  if not OkayToPaint then Exit;

  {set horizontal scroll bar}
  if FScreenDevice.PageImage.Width > FScrollBox.Width then
    begin
      FScrollBox.HorzScrollBar.Range := FScreenDevice.PageImage.Width;
      FScrollBox.HorzScrollBar.Visible := True;
    end
  else
   begin
      FScrollBox.HorzScrollBar.Range := ClientWidth;
      FScrollBox.HorzScrollBar.Visible := False;
   end;

  {set vertical scroll bar}
  if FScreenDevice.PageImage.Height > FScrollBox.Height then
    begin
      FScrollBox.VertScrollBar.Range := FScreenDevice.PageImage.Height;
      FScrollBox.VertScrollBar.Visible := True;
    end
  else
   begin
      FScrollBox.VertScrollBar.Range := ClientHeight;
      FScrollBox.VertScrollBar.Visible := False;
   end;

  {reposition thumbs}
  if FNeedToUpdateScrollBars then
    begin
      FScrollBox.HorzScrollBar.Position := 0;
      FScrollBox.VertScrollBar.Position := 0;

      FNeedToUpdateScrollBars := False;
    end;

end; {procedure, UpdateScrollBars}


{@TppViewer.GotoPage
 Call the GotoPage function to request a single page of the report.

 If GotoPage cannot successfully generate the requested page, it returns False.}

procedure TppViewer.GotoPage(aAbsolutePageNo: Longint);
begin
  FScreenDevice.GotoPage(aAbsolutePageNo);
end; {function, GotoPage}


{@TppViewer.NextPage
 Call the NextPage method to send the next page of the report to the current
 Device.  This is usually called when a user is previewing.}

procedure TppViewer.NextPage;
begin

  if (FScreenDevice.Page.LastPage) then Exit;

  FScreenDevice.GotoPage(FScreenDevice.AbsolutePageNo + 1);

end; {procedure, NextPage}


{@TppViewer.PriorPage
 Call the PriorPage method to send the prior page of the report to the current
 device.  This is usually called when a user is previewing.}

procedure TppViewer.PriorPage;
begin

  if (FScreenDevice.Page.AbsolutePageNo = 1) then Exit;

  FScreenDevice.GotoPage(FScreenDevice.AbsolutePageNo - 1);

end; {procedure, PriorPage}


{@TppViewer.FirstPage
 Call the FirstPage method to request the first page of the report.}
procedure TppViewer.FirstPage;
begin
  FScreenDevice.FirstPage;
end; {procedure, FirstPage}


{@TppViewer.LastPage
 Call the LastPage method to request the last page of the report.}

procedure TppViewer.LastPage;
begin
  FScreenDevice.LastPage;
end; {procedure, LastPage}

{------------------------------------------------------------------------------}
{ TppViewer.Scroll }

procedure TppViewer.Scroll(aDirection: TppDirectionType);
var
  lScrollBar: TControlScrollBar;
begin

  case aDirection of

    dtUp:
      begin
        lScrollBar := FScrollBox.VertScrollBar;
        lScrollBar.Position := lScrollBar.Position - FScrollBox.Height;
      end;
    dtDown:
      begin
        lScrollBar := FScrollBox.VertScrollBar;
        lScrollBar.Position := lScrollBar.Position + FScrollBox.Height;
      end;
    dtLeft:
      begin
        lScrollBar := FScrollBox.HorzScrollBar;
        lScrollBar.Position := lScrollBar.Position - FScrollBox.Width;
      end;
    dtRight:
      begin
        lScrollBar := FScrollBox.HorzScrollBar;
        lScrollBar.Position := lScrollBar.Position + FScrollBox.Width;
      end;

  end;

end; {procedure, Scroll}

{------------------------------------------------------------------------------}
{ TppViewer.OpenWebAddress }

procedure TppViewer.OpenWebAddress(aWebAddress: String);
var
  lbHandled: Boolean;
begin

  lbHandled := False;

  if Assigned(FOnHyperLinkClick) then FOnHyperLinkClick(Self, aWebAddress, lbHandled);

  if not lbHandled then
     ppShellExec(aWebAddress, '', '', SW_SHOWNORMAL);

end;

{------------------------------------------------------------------------------}
{ TppViewer.StartJobEvent }

procedure TppViewer.StartJobEvent(Sender: TObject);
begin
  FEnabled := True;

  DoOnPrintStateChange;
end;

{------------------------------------------------------------------------------}
{ TppViewer.EndJobEvent }

procedure TppViewer.EndJobEvent(Sender: TObject);
begin
  DoOnPrintStateChange;
end; {procedure, EndJobEvent}

{------------------------------------------------------------------------------}
{ TppViewer.CancelJobEvent }

procedure TppViewer.CancelJobEvent(Sender: TObject);
begin
  DoOnPrintStateChange;
end; {procedure, CancelJobEvent}

{------------------------------------------------------------------------------}
{ TppViewer.FindClickableDrawCommand }

function TppViewer.FindClickableDrawCommand(aX, aY: Integer; var aDrawCommand: TppDrawCommand): Boolean;
var
  liIndex: Integer;
  lDrawCommand: TppDrawCommand;
  lbFound: Boolean;
begin

  liIndex := 0;
  lbFound := False;
  lDrawCommand := nil;

  while (liIndex <= FScreenDevice.Page.ClickableCount - 1) and not(lbFound) do
    begin
      lDrawCommand := FScreenDevice.Page.Clickables[liIndex];

      lbFound := (aX >= lDrawCommand.DrawLeft) and
                 (aX <= lDrawCommand.DrawRight) and
                 (aY >= lDrawCommand.DrawTop) and
                 (aY <= lDrawCommand.DrawBottom) and
                 (lDrawCommand.Clickable);

      Inc(liIndex);
    end;

  if lbFound then
    aDrawCommand := lDrawCommand;

  Result := lbFound;

end; {procedure, FindClickableDrawCommand}

{------------------------------------------------------------------------------}
{ TppViewer.FindClickableDrawCommand }

function TppViewer.FindClickableDrawCommand(var aDrawCommand: TppDrawCommand): Boolean;
var
  lPoint: TPoint;
begin

  GetCursorPos(lPoint);

  lPoint := PaintBox.ScreenToClient(lPoint);

  Result := FindClickableDrawCommand(lPoint.X, lPoint.Y, aDrawCommand);

end;

{------------------------------------------------------------------------------}
{ TppViewer.GetCurrentPage }

function TppViewer.GetCurrentPage: TppPage;
begin
  Result := FScreenDevice.Page;
end; {function, GetCurrentPage}
 
{------------------------------------------------------------------------------}
{ TppViewer.IsResizing }

function TppViewer.IsResizing: Boolean;
begin
  Result := Resizing;
end; {function, IsResizing}

{------------------------------------------------------------------------------}
{ TppViewer.GetResizing }

function TppViewer.GetResizing: Boolean;
begin
  Result := (FResizeCount > 0);
end;  {function, GetResizing}

{------------------------------------------------------------------------------}
{ TppViewer.SetResizing }

procedure TppViewer.SetResizing(aResizing: Boolean);
begin

  if aResizing then
    Inc(FResizeCount)
  else
    Dec(FResizeCount);

  if (FResizeCount < 0) then
    FResizeCount := 0;

end;  {procedure, SetResizing}

{******************************************************************************
 *
 ** S C R E E N   D E V I C E
 *
{******************************************************************************}

{------------------------------------------------------------------------------}
{ TppScreenDevice.Create }

constructor TppScreenDevice.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);

  FShowStatus := True;

  if (aOwner is TppViewer) then
    begin
      FViewer := TppViewer(aOwner);

      PageImage.Width  := FViewer.Width;
      PageImage.Height := FViewer.Height;
    end

  else
    FViewer := nil;

  EventNotifies := EventNotifies + [ciEngineNoData];

end; {constructor Create}

{------------------------------------------------------------------------------}
{ TppGraphicsDevice.Cancel }

procedure TppScreenDevice.Cancel;
begin
  if (FViewer = nil) or (FViewer.Report = nil) then Exit;

  FViewer.Report.Cancel;

end; {procedure, Cancel}

{------------------------------------------------------------------------------}
{ TppScreenDevice.DeviceName }

class function TppScreenDevice.DeviceName: String;
begin
  Result := 'Screen';
end; {class function, DeviceName}

{------------------------------------------------------------------------------}
{ TppScreenDevice.EventNotify}

procedure TppScreenDevice.EventNotify(aCommunicator: TppCommunicator; aEventID: Integer; aParams: TraParamList);
begin
  inherited EventNotify(aCommunicator, aEventID, aParams);

  {if no data, need to explicitly render a blank page image}
  if (aEventID = ciEngineNoData) and (aCommunicator = FViewer.FProducer) then
    RenderPage;

end;  {procedure, EventNotify}

{------------------------------------------------------------------------------}
{ TppScreenDevice.Notify}

procedure TppScreenDevice.Notify(aCommunicator: TppCommunicator; aOperation: TppOperationType);
begin

  {clear report property of viewer}
  if (aCommunicator = Publisher) and (aOperation = ppopRemove) then

    if (FViewer <> nil) and not(csDestroying in FViewer.ComponentState) then
      begin
        FViewer.FProducer := nil;
        FViewer.Reset;
      end;


  {this clears the publisher property}
  inherited Notify(aCommunicator, aOperation);

end; {procedure, Notify}

{------------------------------------------------------------------------------}
{ TppScreenDevice.AfterReceivePage }

procedure TppScreenDevice.AfterReceivePage(aPage: TppPage);
begin

  if (FViewer = nil) then Exit;

  if (csDesigning in ComponentState) and not(FViewer.DesignViewer) then Exit;

  FViewer.UpdateScrollBars;

  if (Publisher <> nil) and (Publisher.ReportCompleted) then
    SetStatus(aPage.PageSetDescription)
  else
    SetStatus(aPage.PageNoDescription);

  FViewer.RefreshPage;

  {notify viewer of page change}
  FViewer.DoOnPageChange;

end; {procedure, AfterReceivePage}

procedure TppScreenDevice.AfterRenderPage;
begin
  if (FViewer <> nil) and not(FViewer.PaintBox.Visible) then
    FViewer.PaintBox.Visible := True;

end;

procedure TppScreenDevice.BeforeRenderPage;
var
  lbSuccess: Boolean;
begin

  if (FViewer <> nil) and not(FViewer.ScrollBox.Visible) then
    begin

      lbSuccess := False;

      try
        if (FViewer.Parent <> nil) then
          lbSuccess := LockWindowUpdate(FViewer.Parent.Handle);

        FViewer.ScrollBox.Visible := True;

        RenderFullBlankPage;

      finally
        if lbSuccess then
          LockWindowUpdate(0);

      end;

      FViewer.Invalidate;
    end
  else
    RenderFullBlankPage;

  Scale := ScaledPageWidth / Page.PageDef.spWidth;

end;

{------------------------------------------------------------------------------}
{ TppScreenDevice.CalculateScaledPageSize}

procedure TppScreenDevice.CalculateScaledPageSize;
var
 liDeadArea: Integer;
 lPageDef: TppPageDef;
 liEighthInch: Integer;
 ldPercentage: Double;
 liZoomPercentage: Integer;
begin

  CalculatedZoom := -1;

  liEighthInch := Round(0.125 * Screen.PixelsPerInch);

  liZoomPercentage := CalculateZoomPercentage;
  ldPercentage := liZoomPercentage / 100;

  lPageDef := Page.PageDef;

  {compute page rectangle size}
  ScaledPageHeight := Round(lPageDef.spHeight * ldPercentage);
  ScaledPageWidth := Round(lPageDef.spWidth * ldPercentage);

  {set area around page border}
  liDeadArea := liEighthInch;

  if (FViewer = nil) then
    begin
      {full page size}
      PageImage.Height := lPageDef.spHeight + (liDeadArea * 2);
      PageImage.Width  := lPageDef.spWidth + (liDeadArea * 2);
    end
  else
    begin
      {set page image height, greater of scaled page and scrollbox}
      if (ScaledPageHeight + (liDeadArea * 2)) > FViewer.ScrollBox.Height then
        PageImage.Height := ScaledPageHeight + (liDeadArea * 2)
      else
        PageImage.Height := FViewer.ScrollBox.Height;

      {set page image width, greater of scaled page and scrollbox}
      if (ScaledPageWidth + (liDeadArea * 2)) > FViewer.ScrollBox.Width then
        PageImage.Width  := ScaledPageWidth + (liDeadArea * 2)
      else
        PageImage.Width := FViewer.ScrollBox.Width
    end;

  if CalculatedZoom = -1 then
    CalculatedZoom := Round((ScaledPageHeight / lPageDef.spHeight) * 100);

end; {procedure, CalculateScaledPageSize}

function TppScreenDevice.CalculateZoomPercentage: Integer;
var
  ldRatio: Double;
  liDeadArea: Integer;
  liEighthInch: Integer;
  liQuarterInch: Integer;
  lPageDef: TppPageDef;
  liScrollBarMargin: Integer;

begin

  liEighthInch := Round(0.125 * Screen.PixelsPerInch);
  liQuarterInch := Round(0.25 * Screen.PixelsPerInch);

  {compute page rectangle size}
  lPageDef := Page.PageDef;
  ldRatio := lPageDef.spWidth / lPageDef.spHeight;


  if (FViewer = nil) or (FViewer.ZoomSetting = zs100Percent) then
    Result := 100

  else if (FViewer.ZoomSetting = zsPercentage) then
    Result := FViewer.ZoomPercentage

  else if  (FViewer.ZoomSetting = zsWholePage) then
    begin
      liDeadArea := liQuarterInch;

      {get size of viewable area}
      PageImage.Height := FViewer.ScrollBox.Height;
      PageImage.Width  := FViewer.ScrollBox.Width;

      ScaledPageHeight := FViewer.ScrollBox.Height - (liDeadArea * 2);
      ScaledPageWidth := Round(ldRatio * ScaledPageHeight);

      {reduce width & height until entire page fits in viewable area}
      if (PageImage.Width > (liDeadArea*2)) and (PageImage.Height > (liDeadArea*2)) then
        while (ScaledPageWidth >= PageImage.Width) do
          begin
            ScaledPageHeight := ScaledPageHeight - liDeadArea;
            ScaledPageWidth := Round(ldRatio * ScaledPageHeight);
          end;

      Result := Round((ScaledPageHeight / lPageDef.spHeight) * 100);
    end
  else   {zsPageWidth}
    begin
      {compute page rectangle size}

      liDeadArea := liEighthInch;
      liScrollBarMargin := Round(Screen.PixelsPerInch * 0.1458);

      {calculate height as less than viewable area}
      ScaledPageWidth := FViewer.ScrollBox.Width - (liDeadArea * 2) - liScrollBarMargin;
      ScaledPageHeight := Round(ScaledPageWidth / ldRatio);

      Result := Round((ScaledPageHeight / lPageDef.spHeight) * 100);

    end; {if, ZoomSetting = zsPageWidth}

end;

{------------------------------------------------------------------------------}
{ TppScreenDevice.DrawUpdateable }

function TppScreenDevice.DrawUpdateable(aDrawCommand: TppDrawCommand): Boolean;
var
  lCanvas: TCanvas;
  lbTransparent: Boolean;
begin

  if (Canvas <> nil) then
    begin
      {make drawcommand opaque in order to erase previous version}
      if (aDrawCommand is TppDrawText) then
        lbTransparent := TppDrawText(aDrawCommand).Transparent
      else
        lbTransparent := False;

      if lbTransparent then
        TppDrawText(aDrawCommand).Transparent := False;

      Result := Draw(aDrawCommand);

      if lbTransparent then
        TppDrawText(aDrawCommand).Transparent := True;


      if not Result then Exit;

      if (FViewer <> nil) then
        begin
          lCanvas := FViewer.PaintBox.Canvas;

          FViewer.IncrementalPainting := True;

          try
            lCanvas.CopyRect(aDrawCommand.DrawRect, PageImage.Canvas, aDrawCommand.DrawRect);
          finally
            FViewer.IncrementalPainting := False;
          end;
        end;
    end

  else
    Result := True;

end; {function, DrawUpdateable}

{------------------------------------------------------------------------------}
{ TppScreenDevice.FinalPagesOnly }

function TppScreenDevice.FinalPagesOnly: Boolean;
begin
  Result := False;
end; {function, FinalPagesOnly}

{ TppScreenDevice.RenderFullBlankPage }

procedure TppScreenDevice.RenderFullBlankPage;
begin

  {clear bitmap of previous drawing}
  CreateNewPageImage;

{$IFDEF NewGraphics}
  FGraphicsContext.Free;
  FGraphicsContext := nil;
{$ENDIF}

  UpdateCanvas;

  {calculate scaled page size}
  CalculateScaledPageSize;

  {draw background}
  Canvas.Brush.Style := bsSolid;
  if (FViewer <> nil) then
    Canvas.Brush.Color := FViewer.Color
  else
   Canvas.Brush.Color := clBtnShadow;

  Canvas.FillRect(Rect(0, 0, PageImage.Width, PageImage.Height));

end;

procedure TppScreenDevice.Reset;
begin

  if (FViewer <> nil) and FViewer.Enabled then
    ResetPageImage;

  inherited Reset;

end;  {procedure, Reset}

{------------------------------------------------------------------------------}
{ TppScreenDevice.ResetPageImage }

procedure TppScreenDevice.ResetPageImage;
begin

  Page.FreeDrawCommands;

  CreateNewPageImage;

{$IFDEF NewGraphics}
  FGraphicsContext.Free;
  FGraphicsContext := nil;
{$ENDIF}

  if (FViewer <> nil) then
    begin
      if (FViewer.Report <> nil) then
        Page.PrinterSetup := FViewer.Report.PrinterSetup;

      PageImage.Width := FViewer.Width;
      PageImage.Height := FViewer.Height;

      RenderPage;

      FViewer.RefreshPage;
    end;

end; {procedure, ResetPageImage}

{------------------------------------------------------------------------------}
{ TppScreenDevice.SetStatus }

procedure TppScreenDevice.SetStatus(const aMessage: String);
begin
  if not(FShowStatus) then Exit;

  if (Status = aMessage) then Exit;

  inherited SetStatus(aMessage);

  if (FViewer <> nil) then
    FViewer.DoOnStatusChange;

  Application.ProcessMessages; {force update}

end; {procedure, SetStatus}


{******************************************************************************
 *
 ** I N I T I A L I Z A T I O N   /   F I N A L I Z A T I O N
 *
{******************************************************************************}


initialization

  RegisterClasses([TppViewer, TppScreenDevice]);

  ppRegisterDevice(TppScreenDevice);

finalization

  ppUnRegisterDevice(TppScreenDevice);

  UnRegisterClasses([TppViewer, TppScreenDevice]);

end. 
